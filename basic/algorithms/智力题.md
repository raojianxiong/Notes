1. [你要在一个n * m的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色 。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？给定格子图的长 n 和宽 m。请返回最多能涂的格子数目。测试样例：1，2  返回 ：1](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day11/DemoOne.md)
   * 智力题哦，左上角涂上选定的颜色，例如红色，那么可以理解为相邻的颜色填为白色，所以剩下的颜色基本就定了，如果是$n*m$是偶数的话，那就是 $(n *m)/2$,奇数的话，那就是$(n*m + 1)/2$
2. [作为一个马场的主人，你要安排你的n匹马和另一个马场的n匹马比赛。你已经知道了对方马场的出站表，即参加每一场的马的强壮程度。当然你也知道你自己的所有马的强壮度。我们假定比赛的结果直接由马的强壮度决定，即更壮的马获胜（若相同则双方不算获胜）,请你设计一个策略，使你能获得尽量多的场次的胜利。给定对方每场比赛的马的强壮程度oppo及你的所有马的强壮程度horses(强壮程度为整数,且数字越大越强壮)，同时给定n,请返回最多能获胜的场次。测试样例，[1,2,3] , [1,2,3] , 3 返回 2](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day11/DemoTwo.md)
3. [你和你的朋友正在玩棋子跳格子的游戏，而棋盘是一个由n个格子组成的长条，你们两人轮流移动一颗棋子，每次可以选择让棋子跳1-3格，先将棋子移出棋盘的人获得胜利。我们知道你们两人都会采取最优策略，现在已知格子数目，并且初始时棋子在第一格由你操作。请你计算你是否能获胜。给定格子的数目n(n为不超过300的正整数),返回一个整数，1代表能获胜，0代表不能获胜。测试样例：3 返回 ：1](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day11/DemoThree.md)
   * 已经在第一个棋子上了，剩下由n-1个棋子，考虑最后一次情况，如果你选择跳 1 - 3 步，假设3步，如果还有格子（1-3），那么就对方赢了，跳3步能赢不会跳一步的吧。所以如果 n - 1个格子是4的倍数，那么你就输了
4. [A与B做游戏。在一个 n * m 的矩阵中的出发点是 (1,m),终点是 (n,1),规则是只能向左移动一格，向下移动一格，或者向左下一移动一格，先走到终点的为winner。A先走。给定两个整数n和m,请返回最后的获胜者的名字(A或B)。测试样例：5 3 返回 ：B](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day11/DemoFour.md)
5. [现在有一个整数数组，其元素值均为 1-n 范围内的某个整数，现在你和你的朋友在玩一个游戏，游戏的目的是把数组清空，你们轮流操作，你是先手，每次操作你可以删除数组中值为某个数的元素任意多个(当然数组中值为这个数的元素个数应大于等于你删除的个数，且至少要删除一个数)。最先把数组清空的人获得胜利。假设你们都采取最优策略，请你计算你能否获得胜利。给定一个整数数组A和元素个数n。请返回一个整数，1代表你能获胜，0代表你不能获胜。测试样例：[1,1,1] 返回：1](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day11/DemoFive.md)
   * 核心思想就是盘算所有数字的统计结果是否有偶数对相同的，如统计结果1有3个，2有3个，没有其他数字，那肯定是后手赢，如果1有2个，2有3个肯定是先手赢，或者是1有3个，2有3个，3有3个还是后手赢。
   * 采用最优策略，可以利用map存放数据。所以如果map的大小为偶数，而你又是先手，那么你就输了







