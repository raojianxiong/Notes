package algo.day03;

import java.util.Stack;

/**
 * 对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree,MaxTree定义为一棵二叉树，
 * 其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，
 * 它的根的元素值为子树的最大值，现有一建数方法，对于数组中的每个元素，
 * 其在树中的父亲为数组中它左边比它大的第一个和右边比它大的第一个数中更小的一个
 * ，若两边都不存在比它大的树，那么它就是树根。请设计O(N)的算法实现这个方法。返回一个数组，
 * 其中每个元素为原数组中对应位置元素再父亲节点的编号，若为根，则为-1
 * 
 * @author Jianxiong Rao
 *
 */
public class DemoSix {

    // 循环处理每一个元素
    // 需要一个额外的栈来辅助获取两个阶段的最大值（两个阶段指左边最大值和右边最大值）
    // 每次判断一个元素分三种情况
    //  1. 栈为空，也就是初始状态，直接将元素下标入栈（此时该元素的父结点下标为默认值 -1）
    //  2. 栈不为空，同时即将进栈的元素比栈顶元素小，那么直接将元素进栈同时更新当前元素的
    //     父结点下标为i(设定父结点为左边第一个比该元素大的，右侧第一个比该元素大的第3步说明)
    //  3. 栈不为空，同时即将进栈的元素比栈顶元素大，那么需要将栈顶元素出栈，然后比较
    //     需要分情况:
    //     1) 栈顶元素对应父结点下标为null， 说明栈顶元素左侧没有最大值，此时需要更新
    //        栈顶元素对应父结点下标为当前进栈元素的下标 i，然后将栈顶元素pop 出栈
    //     2) 栈顶元素对应的父结点下标对应数组中元素比，i 位置对应数组元素大，由maxTree 的
    //        定义，我们必须保存左侧和右侧相对较小的那个作为最终结果，所以也更新元素下标为i
    //        然后将栈顶元素 pop 出栈

  public int[] buildMaxTree(int[] A,int n) {
	  //条件
	  int[] index = new int[n];//存放每个父亲节点
	  for(int i = 0;i<n;i++) {
		  index[i]= -1; 
	  }
	  //辅助栈 maxtree的下标
	  Stack<Integer> stack = new Stack<>();
	  
	  for(int i = 0;i<n;i++) {
		  //其实就是遍历到当前数的时候考虑左侧的数
		  while(!stack.isEmpty() && A[stack.peek()] < A[i]) {
			// 如果即将《被pop 元素》的左侧最大值为null 或者其左侧最大值比右侧(A[i])最大值大
			  if(index[stack.peek()] == -1 || A[index[stack.peek()]] > A[i]) {
				// 需要先更新该元素的父结点为右侧结点下标
				  index[stack.peek()] = i;
			  }
			//如果左侧最大值比右侧大，就需要将左侧的下标弹出,继续比较它前面的元素
			  stack.pop();
		  }
		  //如果不空，更新当前元素左侧第一个比它大的父结点为栈顶元素
		  if(!stack.isEmpty()) {
			  index[i]= stack.peek(); //左侧元素比它大，左侧元素为其父节点
		  }
		  stack.push(i);
	  }
	
	  return index;
  }
}
