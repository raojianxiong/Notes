1. [给定数组arr,arr中所有的值都为正数且不重复，每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim(小于等于1000)代表要找的钱数，求换钱有多少种方法。](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day10/DemoOne.md)
   * 暴力搜索方法
     * arr = {5,10,25,1} aim =1000
     * 用0张5元的货币，让[10,25,1]组成剩下的1000   -------- 结果res1种
     * 用1张5元的货币,让[10,25,1] 组成剩下的995 ---------------结果res2种
     * ...............
     * 用200张5元的货币，rang[10,25,1]组成剩下的0，方法数-------res201
     * 累加就是结果，有点冗余，递归解法，复杂度很高
   * 记忆搜索方法
     * 因为暴力搜索方法内，递归解法，有些方法值是重复计算的，所以需要保存起来，放入Map种以减少时间消耗
   * 动态规划方法
     * arr长度为N，生成行数为N，列数为 aim+1 的矩阵dp，$dp[i][j]$的含义是在使用$arr[0........i]$的情况下，组成钱数 j 有多少种方法
     * $dp[i][j] $ 如果完全不用arr[i] 货币，只是用arr[0........i-1]货币时，方法数为$dp[i-1][j]$
     * 如果使用1张arr[i]货币，剩下的钱数用arr[0........i-1]货币时，方法数为$dp[i-1][j-1*arr[i]$
     * 以此类推，所以求每一个位置都需要枚举，时间复杂度为O(aim),dp一共有N*aim个位置，所以时间复杂度为$O(N^2)$
   * 记忆搜索方法与动态规划方法的联系
     * 记忆搜索方法就是某种形态的动态规划方法
     * 记忆化搜索方法不关心到达某一个递归过程的路径，只是单纯地对计算过地递归过程进行记录，避免重复地递归过程
     * 动态规划地方法则是规定好每一个递归过程地计算顺序，依次进行计算，后面地计算过程严格以来前面的计算过程

2. [有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法？](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day10/DemoTwo.md)
   * n=1,就有一种走法，n=2,那就有2种走法
   * n级台阶，可以先走一步，剩下走法f(n-1) 或者先走两步，剩下f(n-2)
   * 得到公式 $f(n) = f(n-1) + f(n-2) $

3. [给定一个矩阵m,从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径种最小的路径和。如果给定的m如大家看到的样子，路径1，3，1，0，6，1，0是所有路径和最小的，所以返回12。](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day10/DemoThree.md)
   * 1	3	5	9
   * 8      1	3	4
   * 5      0      6      1
   * 8      8      4      0
   * 矩阵大小为 M * N，$dp[i][j] $ 的值表示从左上角，也就是(0,0) 位置，走到$(i,j)$ 位置的最小路径和
   * $dp[i][j] = map[i][j] + Math.min(dp[i-1][j] ,dp[i][j-1]) $

4. [给定数组arr,返回arr的最长递增子序列长度。比如$arr=[2,1,5,3,6,4,8,9,7]$,最长递增子序列为[1,3,4,8,9],所以返回这个子序列的长度5。给定数组arr，返回arr的最长递增子序列长度。](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day10/DemoFour.md)
   * dp[i] 表示在必须以 arr[i] 这个数结尾的情况下，arr[0......i] 中的最大递增子序列长度。

5. [给定两个字符串str1和str2，返回两个字符串的最长公共子序列。例如 str1 = "1A2C3D4B56",str2="B1D23CA45B6A","123456"或者"12C4B6"都是最长公共子序列，返回哪一个都行](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day10/DemoFive.md)
   * str1的长度为M，str2的长度为N，生成大小为M*N的矩阵dp。$dp[i][j]$ 的含义是str1[0....i] 与 str2[0......j]的公共子序列的长度 

6. [一个背包有一定的承重W，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day10/DemoSix.md)
   * 物品编号1到N，也就是v的长度为N，w的长度为M，新建大小为 N * (W+1)的矩阵
   * $dp[x][y] $ 代表前x件物品，不超过重量y的时候最大价值
   * 那么计算$dp[x][y]$就需要考虑是否选择x件物品，选择，则前x-1件物品不得超过y-w[x],不选择则不能超过y

7. [给定两个字符串str1和str2，再给定三个整数ic、dc、和rc,分别代表插入、删除、和替换一个字符的代价。返回将str1编辑成str2的最小代价。比如，str1="abc",str2="adc",ic=5,dc=3,rc=2。从”abc"编辑成"adc"，把"b"替换成"d"是代价最小的，所以返回2。再比如，str1="abc",str2="adc",ic=5,dc=3,rc=100。从"abc"编辑成"adc",先删除b，然后再插入"d"是代价最小的，所以返回8。给定两个字符串A和B，以及它们的长度和三种操作的代价，请返回将A变成B的最小代价。](https://github.com/raojianxiong/Notes/blob/master/basic/algorithms/day10/DemoSeven.md)

   * str1的长度为M，str2的长度为N，首先生成大小为(M+1) * （N+1）的矩阵dp，0行0列
   * 对应的字符串为空字符串
   * $dp[i][j]$ 的值代表 str1[0....i-1]编辑成str2[0....j-1] 的最小代价
   * $求dp[i][j]，即str1[0....i-1]编辑成str2[0.....j-1]，四种可能的途径：$

     * $str1[0....i-1]先编辑成str2[0.....j-2]，再由str2[0.....j-2]到str2[0.....j-1]，即dp[i][j-1]+ic;$

     * $str1[0....i-1]先编辑成str1[0.....i-2]，再由str1[0.....i-2]到str2[0.....j-1]，即dc+dp[i-1][j];$

     * $如果str1[i-1]==str2[j-1],则dp[i][j]=dp[i-1][j-1];$

     * $如果str1[i-1]!=str2[j-1],则dp[i][j]=dp[i-1][j-1]+rc;$
